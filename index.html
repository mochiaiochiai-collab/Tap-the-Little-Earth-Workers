<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tap the Little Earth Workers</title>
  <link href="https://fonts.googleapis.com/css2?family=Freckle+Face&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #fffefb;
      --panel: #ffffff;
      --text: #1f2937;
      --accent: #2563eb;
      --good: #16a34a;
      --bad: #dc2626;
    }
    html, body {
      font-family: 'Noto Sans JP', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: grid; place-items: center;
      padding: clamp(12px, 3vw, 24px);
      min-height: 100dvh;
      overflow-x: hidden;
    }
    .app { width: min(900px, 96vw); height: 100%; }
    .card {
      position: relative;
      background: var(--panel);
      border: 2px solid rgba(0,0,0,0.06);
      border-radius: 28px; padding: 20px 50px 24px; box-shadow: 0 20px 50px rgba(31,41,55,0.12);
      display: flex; flex-direction: column; height: 80%; overflow: hidden;
    }
    .card::before {
      content: ""; position: absolute; inset: -40px; z-index: 0; pointer-events: none;
      background:
        radial-gradient(120px 80px at 10% 15%, rgba(255, 99, 132, .18), transparent 70%),
        radial-gradient(160px 120px at 85% 10%, rgba(99, 102, 241, .18), transparent 70%),
        radial-gradient(160px 140px at 12% 90%, rgba(16, 185, 129, .18), transparent 70%),
        radial-gradient(180px 120px at 90% 85%, rgba(6, 182, 212, .18), transparent 70%),
        radial-gradient(220px 140px at 50% -10%, rgba(250, 204, 21, .18), transparent 70%);
      filter: blur(18px) saturate(120%);
      mask: radial-gradient(closest-side, transparent 64%, black 66%);
    }
    .card > * { position: relative; z-index: 1; }

    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 16px; }
    h1 { font-family: 'Freckle Face', 'Noto Sans JP', sans-serif; font-weight: 400; font-size: clamp(22px, 3.6vw, 34px); margin: 0; letter-spacing: .02em;
      background: linear-gradient(90deg, #ff2b8a, #ff65c3 50%, #ff2b8a 100%);
      -webkit-background-clip: text; color: transparent; }
    h2 { font-family: 'Freckle Face', 'Noto Sans JP', sans-serif; font-weight: 400; font-size: clamp(16px); margin: 0; letter-spacing: .02em;
      background: linear-gradient(90deg, #ff2b8a, #ff65c3 50%, #ff2b8a 100%);
      -webkit-background-clip: text; color: transparent; }
    .titleblock { display: flex; flex-direction: column; gap: 4px; }
    .subtitle { font-family: 'Noto Sans JP', system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-size: clamp(12px, 1.8vw, 14px); line-height: 1.6; color: #475569; margin: 4px 0 0; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; align-items: stretch; }
    .controls button {
      appearance: none; border: 0; border-radius: 999px; padding: 10px 16px;
      font-family: 'Freckle Face', 'Noto Sans JP', sans-serif;
      background: linear-gradient(180deg, #fde68a, #facc15);
      color: #3f301e; font-weight: 400; cursor: pointer;
      transition: transform .08s ease, box-shadow .2s ease, opacity .2s;
      box-shadow: 0 8px 20px rgba(190, 120, 20, .25);
    }
    button {
      appearance: none; border: 0; border-radius: 999px; padding: 10px 16px;
      font-family: 'Freckle Face', 'Noto Sans JP', sans-serif;
      background: linear-gradient(180deg, #fde68a, #facc15);
      color: #3f301e; font-weight: 400; cursor: pointer;
      transition: transform .08s ease, box-shadow .2s ease, opacity .2s;
      box-shadow: 0 8px 20px rgba(190, 120, 20, .25);
    }
    button.secondary { background: linear-gradient(180deg, #e0f2fe, #bae6fd); color: #0f172a; border: 0; box-shadow: 0 8px 20px rgba(59,130,246,.25); }
    button:active { transform: translateY(1px) scale(.98); }

    .hud { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin: 12px 0 18px;  font-family: 'Freckle Face', 'Noto Sans JP', sans-serif; }
    .hud > div { background: rgba(255,255,255,.85); border: 1px solid rgba(0,0,0,.06); padding: 10px 12px; border-radius: 14px; text-align: center; box-shadow: inset 0 0 0 1px rgba(255,255,255,.5); }
    .hud .value { font-size: 22px; font-weight: 800; }

    .board {
      position: relative;
      width: min(500px, 100%);
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      border-radius: 24px;
      border: 2px solid rgba(60, 40, 25, .18);
      background: radial-gradient(120% 120% at 30% 20%, #b08968, #a47148 35%, #7f5539 75%);
      overflow: hidden;
      padding: 14px; box-sizing: border-box;
    }
    .board::before {
      content: ""; position: absolute; inset: -30px; pointer-events: none;
      background:
        radial-gradient(140px 100px at 12% 18%, rgba(255, 237, 213, .20), transparent 70%),
        radial-gradient(160px 120px at 88% 16%, rgba(120, 72, 48, .18), transparent 70%),
        radial-gradient(220px 160px at 18% 84%, rgba(255, 200, 150, .16), transparent 70%),
        radial-gradient(200px 140px at 86% 86%, rgba(60, 40, 25, .20), transparent 70%);
      filter: blur(18px) saturate(110%);
      mix-blend-mode: multiply;
    }
    .holes { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 14px; height: 100%; }
    .hole {
      position: relative; background: linear-gradient(180deg, #e7d3bd, #d9c2a8);
      border-radius: 18px; border: 1px solid rgba(63, 48, 30, .18); overflow: hidden;
      display: grid; align-items: end; justify-items: center; padding-bottom: 8px;
    }
    .lip { position: absolute; inset: auto 8px 8px; height: 10px; background: #5c4532; opacity: .22; border-radius: 10px; filter: blur(2px); }
    .sprite {
      width: 76%; max-width: 180px; aspect-ratio: 1 / 1; object-fit: contain; user-select: none; pointer-events: none;
      transform: translateY(110%); transition: transform .18s ease-out; filter: drop-shadow(0 10px 12px rgba(0,0,0,.45));
    }
    .up .sprite { transform: translateY(0%); }
    .hitflash { position: absolute; inset: 0; background: rgba(255, 221, 0, 0.38); border-radius: 20px; opacity: 0; transition: opacity .18s; }
    .hole.hit { background: linear-gradient(180deg, #ffe88a, #ffd54f); }
    .hole.hit .hitflash { opacity: 1; }
    .tapzone { position: absolute; inset: 0; cursor: pointer; }

    footer { opacity: .8; margin-top: 6px; font-size: 12px; text-align: center; }
    footer:empty { margin: 0; height: 0; padding: 0; }
    a { color: var(--accent); }

    /* Emphasize START button (same size, glowing pulse) */
    #startBtn {
      border: 2px solid rgba(255, 183, 3, .6);
      box-shadow: 0 8px 20px rgba(190,120,20,.25), 0 0 0 0 rgba(255,183,3,.45);
      animation: pulseGlow 1.8s ease-out infinite;
    }
    #startBtn.running, #startBtn:disabled { animation: none; opacity: .9; }
    @keyframes pulseGlow {
      0%   { box-shadow: 0 8px 20px rgba(190,120,20,.25), 0 0 0 0 rgba(255,183,3,.45); }
      70%  { box-shadow: 0 8px 20px rgba(190,120,20,.25), 0 0 0 14px rgba(255,183,3,0); }
      100% { box-shadow: 0 8px 20px rgba(190,120,20,.25), 0 0 0 0 rgba(255,183,3,0); }
    }
    @media (prefers-reduced-motion: reduce) { #startBtn { animation: none; } }

    /* Countdown overlay */
    .countdown {
      position: absolute; inset: 0; display: grid; place-items: center;
      font-family: 'Freckle Face', 'Noto Sans JP', sans-serif;
      font-size: clamp(56px, 16vw, 140px);
      color: #fff; text-shadow: 0 4px 16px rgba(0,0,0,.45);
      pointer-events: none; user-select: none;
    }
    .countdown.show { animation: pop .6s ease-out both; }
    @keyframes pop { from { transform: scale(.6); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    /* Finale wobble animation */
    @keyframes wobble { 0%{ transform: translateY(0) rotate(0deg);} 25%{ transform: translateY(-2%) rotate(-3deg);} 50%{ transform: translateY(0) rotate(0deg);} 75%{ transform: translateY(-2%) rotate(3deg);} 100%{ transform: translateY(0) rotate(0deg);} }
    .finale .sprite { animation: wobble 1.1s ease-in-out infinite; }

    /* Mobile tweaks: shrink padding to avoid overflow */
    @media (max-width: 480px) {
      .card { padding: 16px 16px 20px; }
      .app { width: 100vw; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <header id="hdr">
        <div class="titleblock">
          <h1>Tap the Little Earth Workers</h1>
          <p class="subtitle">ここは豊かな土壌が自慢の畑。元気な微生物がたくさんいるよ！<br>穴から出てくる微生物をタップしてスコアを稼ごう！<br>外すと−1点。時間が0になると、みんなでダンスするよ！</p>
          <div class="controls">
            <button id="startBtn">START</button>
            <button id="stopBtn" class="secondary">STOP</button>
          </div>
        </div>
      </header>

      <div class="hud" id="hud">
        <div>Score<br><span id="score" class="value">0</span></div>
        <div>TIME<br><span id="time" class="value">20</span>s</div>
        <div>Best<br><span id="best" class="value">0</span></div>
      </div>

      <div class="board" id="board">
        <div class="holes" id="holes"></div>
        <div class="countdown" id="countdown" hidden></div>
      </div>

      <footer id="ftr">
      
      </footer>
    </div>
  </div>

  <script>
    // === 設定（ここだけ差し替えればOK） ==============================
    const SPRITES = [
      'bio.png',
      'cell.png',
      'fangi.png',
      'gel.png',
      'mikrobe.png',
      'jim.png',
      'ss.png',
      'mol.png',
      'spore.png'
    ];
    const HOLE_COUNT = 9;
    const SPAWN_MS = 850;
    const UP_DURATION = 650;
    const GAME_SECONDS = 20;
    const MISS_PENALTY = -1;
    // --- Preload sprites for consistent start ---
    const ASSET_URLS = SPRITES.map(n => `assets/${n}`);
    let assetsReady = false;
    let assetsPromise = preloadImages(ASSET_URLS).then(() => { assetsReady = true; });
    // ================================================================

    const $holes = document.getElementById('holes');
    const $score = document.getElementById('score');
    const $time  = document.getElementById('time');
    const $best  = document.getElementById('best');
    const $start = document.getElementById('startBtn');
    const $stop  = document.getElementById('stopBtn');
    const $board = document.getElementById('board');
    const $hdr = document.getElementById('hdr');
    const $hudEl = document.getElementById('hud');
    const $ftr = document.getElementById('ftr');

    // precise schedulers
    let timeTO = null; // countdown timeout id
    let spawnTO = null; // spawn timeout id

    let timer = null;
    let spawner = null;
    let running = false;
    let countingDown = false;
    let timeLeft = GAME_SECONDS;
    let score = 0;
    let best = Number(localStorage.getItem('microbe-best') || 0);
    $best.textContent = best;

    const holes = [...Array(HOLE_COUNT)].map(() => createHole());
    holes.forEach(h => $holes.appendChild(h.root));

    function createHole() {
      const root = document.createElement('div');
      root.className = 'hole';
      const img = document.createElement('img');
      img.className = 'sprite';
      img.alt = 'microbe';
      img.src = transparentPixel();
      const lip = document.createElement('div');
      lip.className = 'lip';
      const flash = document.createElement('div');
      flash.className = 'hitflash';
      const zone = document.createElement('div');
      zone.className = 'tapzone';
      root.appendChild(img);
      root.appendChild(lip);
      root.appendChild(flash);
      root.appendChild(zone);
      let up = false;
      let hideTO = null;
      zone.addEventListener('pointerdown', () => {
        if (!running || countingDown) return;
        if (up) {
          score++;
          $score.textContent = score;
          root.classList.add('hit');
          setTimeout(() => root.classList.remove('hit'), 120);
          clearTimeout(hideTO);
          down();
        } else if (MISS_PENALTY) {
          score += MISS_PENALTY;
          $score.textContent = score;
        }
      });
      function upWith(spriteUrl) {
        img.src = spriteUrl;
        root.classList.add('up');
        up = true;
        hideTO = setTimeout(down, UP_DURATION);
      }
      function down() {
        root.classList.remove('up');
        up = false;
        setTimeout(() => { img.src = transparentPixel(); }, 180);
      }

      function showPersistent(spriteUrl) {
        clearTimeout(hideTO);
        img.src = spriteUrl;
        root.classList.add('up');
        up = true;
      }

      return { root, upWith, down, showPersistent, get up() { return up; } };
    }

    async function startGame() {
      if (running) return;
      // 再スタート時：フィナーレ状態や出しっぱなしをクリア
      holes.forEach(h => { h.root.classList.remove('finale'); h.down(); });
      running = true;
      score = 0; $score.textContent = score;
      timeLeft = GAME_SECONDS; $time.textContent = timeLeft;
      // lock start during countdown
      $start.classList.add('running'); $start.disabled = true; countingDown = true;
      // ensure assets are loaded before starting to avoid first-frame lag
      if (!assetsReady) { try { await assetsPromise; } catch (e) { /* ignore */ } }

      await runCountdown();
      countingDown = false;
      startSpawner();
      startTimer();
    }

    function stopGame() {
      if (!running || countingDown) return;
      running = false;
      clearInterval(spawner); spawner = null; // legacy
      clearInterval(timer); timer = null;     // legacy
      clearTimeout(spawnTO); spawnTO = null;  // new precise
      clearTimeout(timeTO); timeTO = null;    // new precise
      holes.forEach(h => h.down());
      const cd = document.getElementById('countdown'); if (cd){ cd.hidden = true; cd.textContent=''; cd.classList.remove('show'); }
      countingDown = false; $start.disabled = false; $start.classList.remove('running');
      if (score > best) {
        best = score; localStorage.setItem('microbe-best', String(best));
        $best.textContent = best;
      }
      setTimeout(finale, 200);
    }

    function pickSprite() {
      const name = SPRITES[Math.floor(Math.random() * SPRITES.length)];
      return `assets/${name}`;
    }

    function transparentPixel() {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';
    }

    // preload images to warm the cache before first spawn
    function preloadImages(urls) {
      return Promise.all(urls.map(url => new Promise((resolve) => {
        const i = new Image();
        i.onload = i.onerror = resolve; // resolve even if missing to avoid hang
        i.src = url;
      })));
    }

    function delay(ms){ return new Promise(r => setTimeout(r, ms)); }
    async function runCountdown(){
      const el = document.getElementById('countdown');
      if (!el) return;
      el.hidden = false;
      // 3 と 2 は通常表示
      for (const n of [3,2]){
        el.textContent = n;
        el.classList.remove('show');
        void el.offsetWidth; // restart animation
        el.classList.add('show');
        await delay(1000);
      }
      // 1 は短く見せて即消す
      el.textContent = 1;
      el.classList.remove('show');
      void el.offsetWidth;
      el.classList.add('show');
      await delay(1000);
      el.hidden = true;
      el.textContent = '';
      el.classList.remove('show');
    }

    // drift-free countdown using performance.now()
    function startTimer() {
      const startTs = performance.now();
      const endTs = startTs + GAME_SECONDS * 1000;
      function tick() {
        if (!running || countingDown) return;
        const now = performance.now();
        const secs = Math.max(0, Math.ceil((endTs - now) / 1000));
        $time.textContent = secs;
        if (now >= endTs) { stopGame(); return; }
        const next = 1000 - ((now - startTs) % 1000);
        timeTO = setTimeout(tick, next);
      }
      tick();
    }

    // timeout-based spawner (avoids setInterval jitter)
    function startSpawner() {
      function loop() {
        if (!running || countingDown) return;
        const candidates = holes.filter(h => !h.up);
        if (candidates.length) {
          const h = candidates[Math.floor(Math.random() * candidates.length)];
          const sprite = pickSprite();
          h.upWith(sprite);
        }
        spawnTO = setTimeout(loop, SPAWN_MS);
      }
      loop();
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function finale() {
      // Show all 9 unique microbes once, wobbling
      const sprites = SPRITES.slice();
      shuffle(sprites);
      const availableHoles = holes.slice();
      shuffle(availableHoles);
      const count = Math.min(sprites.length, availableHoles.length);
      for (let i = 0; i < count; i++) {
        const h = availableHoles[i];
        h.showPersistent(`assets/${sprites[i]}`);
        h.root.classList.add('finale');
      }
    }

    /* layoutBoard removed: fixed 500px board */
    /* removed resize listener */
    /* removed orientationchange listener */
    /* removed ResizeObserver to avoid loop error */
    /* layoutBoard call removed */

    $start.addEventListener('click', startGame);
    $stop.addEventListener('click', stopGame);

    $holes.style.gridTemplateColumns = 'repeat(3, 1fr)';
    $holes.style.gridTemplateRows = 'repeat(3, 1fr)';
  </script>
</body>
</html>


